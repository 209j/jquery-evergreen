<!DOCTYPE html><html lang="en"><head><title>je/event</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="je/event"><meta name="groc-project-path" content="src/je/event.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/je/event.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="events">Events</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper">import { global, makeIterable } from <span class="string">'./util'</span>;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="on">on</h2>
<p>Shorthand for <code>addEventListener</code>. Supports event delegation if a filter (<code>selector</code>) is provided.</p>
<pre><code>$(&#39;.item&#39;).on(&#39;click&#39;, callback);
$(&#39;.container&#39;).on(&#39;click&#39;, &#39;.item&#39;, handler);</code></pre>
<p>Parameters:</p>
<ul>
<li><p><strong>eventName must be a String.</strong></p>
</li>
<li><p><strong>selector is optional and must be a String.</strong><br/>(Selector to filter descendants that delegate the event to this element.)</p>
</li>
<li><p><strong>handler must be a Function.</strong><br/>(Event handler)</p>
</li>
<li><p><strong>useCapture must be a Boolean and has a default value of false.</strong></p>
</li>
</ul>
<p><strong>Returns a Node or a NodeList or a $Object</strong><br/>(Returns the object it was applied to (<code>this</code>).)</p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span><span class="params">(eventName, selector, handler, useCapture)</span> {</span>

    <span class="keyword">if</span>(<span class="keyword">typeof</span> selector === <span class="string">'function'</span>) {
        handler = selector;
        selector = <span class="literal">null</span>;
    }

    <span class="keyword">var</span> parts = eventName.split(<span class="string">'.'</span>);
    eventName = parts[<span class="number">0</span>] || <span class="literal">null</span>;
    <span class="keyword">var</span> namespace = parts[<span class="number">1</span>] || <span class="literal">null</span>;

    <span class="keyword">var</span> eventListener = handler;

    makeIterable(<span class="keyword">this</span>).forEach(<span class="function"><span class="keyword">function</span><span class="params">(element)</span> {</span>

        <span class="keyword">if</span>(selector) {
            eventListener = delegateHandler.bind(element, selector, handler);
        }

        element.addEventListener(eventName, eventListener, useCapture || <span class="literal">false</span>);

        getHandlers(element).push({
            eventName: eventName,
            handler: handler,
            eventListener: eventListener,
            selector: selector,
            namespace: namespace
        });
    });

    <span class="keyword">return</span> <span class="keyword">this</span>;
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="off">off</h2>
<p>Shorthand for <code>removeEventListener</code>. Delegates to <code>undelegate</code> if that signature is used.</p>
<pre><code>$(&#39;.item&#39;).off(&#39;click&#39;, callback);</code></pre>
<p>Parameters:</p>
<ul>
<li><p><strong>eventName must be a String.</strong><br/>(Name or type of the event)</p>
</li>
<li><p><strong>selector is optional and must be a String.</strong><br/>(Selector to filter descendants that undelegate the event to this element.)</p>
</li>
<li><p><strong>handler must be a Function.</strong><br/>(Event handler)</p>
</li>
<li><p><strong>useCapture must be a Boolean and has a default value of false.</strong></p>
</li>
</ul>
<p><strong>Returns a Node or a NodeList or a $Object</strong><br/>(Returns the object it was applied to (<code>this</code>).)</p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> off = <span class="function"><span class="keyword">function</span><span class="params">(eventName, selector, handler, useCapture)</span> {</span>

    <span class="keyword">if</span>(<span class="keyword">typeof</span> selector === <span class="string">'function'</span>) {
        handler = selector;
        selector = <span class="literal">null</span>;
    }

    <span class="keyword">if</span>(eventName) {
        <span class="keyword">var</span> parts = eventName.split(<span class="string">'.'</span>);
        eventName = parts[<span class="number">0</span>];
        <span class="keyword">var</span> namespace = parts[<span class="number">1</span>];
    }

    makeIterable(<span class="keyword">this</span>).forEach(<span class="function"><span class="keyword">function</span><span class="params">(element)</span> {</span>

        <span class="keyword">var</span> handlers = getHandlers(element) || [];

        <span class="keyword">if</span>(!eventName &amp;&amp; !namespace &amp;&amp; !selector &amp;&amp; !handler) {

            handlers.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> {</span>
                element.removeEventListener(item.eventName, item.eventListener, useCapture || <span class="literal">false</span>);
            });

            clearHandlers(element);

        } <span class="keyword">else</span> {

            handlers.filter(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> {</span>
                <span class="keyword">return</span> ((!eventName || item.eventName === eventName) &amp;&amp;
                    (!namespace || item.namespace === namespace) &amp;&amp;
                    (!handler || item.handler === handler) &amp;&amp;
                    (!selector || item.selector === selector));
            }).forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> {</span>
                element.removeEventListener(item.eventName, item.eventListener, useCapture || <span class="literal">false</span>);
                handlers.splice(handlers.indexOf(item), <span class="number">1</span>);
            });

            <span class="keyword">if</span>(handlers.length === <span class="number">0</span>) {
                clearHandlers(element);
            }
        }

    });

    <span class="keyword">return</span> <span class="keyword">this</span>;
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="delegate">delegate</h2>
<p>Delegate events triggered at descendants to element(s)</p>
<pre><code>$(&#39;.container&#39;).delegate(&#39;.item&#39;, &#39;click&#39;, handler);</code></pre>
<p>Parameters:</p>
<ul>
<li><p><strong>selector must be a String.</strong><br/>(Selector to filter descendants that delegate the event to this element.)</p>
</li>
<li><p><strong>eventName must be a String.</strong><br/>(Name or type of the event)</p>
</li>
<li><p><strong>fn must be a Function.</strong><br/>(Event handler)</p>
</li>
</ul>
<p><strong>Returns a Node or a NodeList or a $Object</strong><br/>(Returns the object it was applied to (<code>this</code>).)</p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> delegate = <span class="function"><span class="keyword">function</span><span class="params">(selector, eventName, fn)</span> {</span>
    <span class="keyword">return</span> on.call(<span class="keyword">this</span>, eventName, selector, fn);
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="undelegate">undelegate</h2>
<p>Undelegate events triggered at descendants to element(s)</p>
<pre><code>$(&#39;.container&#39;).undelegate(&#39;.item&#39;, &#39;click&#39;, handler);</code></pre>
<p>Parameters:</p>
<ul>
<li><p><strong>selector must be a String.</strong><br/>(Selector to filter descendants that undelegate the event to this element.)</p>
</li>
<li><p><strong>eventName must be a String.</strong><br/>(Name or type of the event)</p>
</li>
<li><p><strong>fn must be a Function.</strong><br/>(Event handler)</p>
</li>
</ul>
<p><strong>Returns a Node or a NodeList or a $Object</strong><br/>(Returns the object it was applied to (<code>this</code>).)</p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> undelegate = <span class="function"><span class="keyword">function</span><span class="params">(selector, eventName, fn)</span> {</span>
    <span class="keyword">return</span> off.call(<span class="keyword">this</span>, eventName, selector, fn);
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="trigger">trigger</h2>
<p>Trigger event at element(s)</p>
<pre><code>$(&#39;.item&#39;).trigger(&#39;anyEventType&#39;);</code></pre>
<p>Parameters:</p>
<ul>
<li><p><strong>type must be a String.</strong><br/>(Type of the event)</p>
</li>
<li><p><strong>params is optional and must be an Object.</strong><br/>(Event parameters (optional))</p>
<ul>
<li><p><strong>params.bubbles must be a Boolean and has a default value of true.</strong><br/>(Does the event bubble up through the DOM or not.)</p>
</li>
<li><p><strong>params.cancelable must be a Boolean and has a default value of true.</strong><br/>(Is the event cancelable or not.)</p>
</li>
<li><p><strong>params.detail can be of any type and has a default value of undefined.</strong><br/>(Additional information about the event.)</p>
</li>
</ul>
</li>
</ul>
<p><strong>Returns a Node or a NodeList or a $Object</strong><br/>(Returns the object it was applied to (<code>this</code>).)</p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> trigger = <span class="function"><span class="keyword">function</span><span class="params">(type, params)</span> {</span>
    params = params || { bubbles: <span class="literal">true</span>, cancelable: <span class="literal">true</span>, detail: <span class="literal">undefined</span> };
    <span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(type, params);
    makeIterable(<span class="keyword">this</span>).forEach(<span class="function"><span class="keyword">function</span><span class="params">(element)</span> {</span>
        <span class="keyword">if</span>(!params.bubbles || isEventBubblingInDetachedTree || isAttachedToDocument(element)) {
            element.dispatchEvent(event);
        } <span class="keyword">else</span> {
            triggerForPath(element, type, params);
        }
    });
    <span class="keyword">return</span> <span class="keyword">this</span>;
};</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private method isAttachedToDocument</span></p>
<p>Check whether the element is attached to (or detached from) the document</p>
<p>Parameters:</p>
<ul>
<li><strong>element must be a Node.</strong><br/>(Element to test)</li>
</ul>
<p><strong>Returns a Boolean</strong></p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> isAttachedToDocument = <span class="function"><span class="keyword">function</span><span class="params">(element)</span> {</span>
    <span class="keyword">if</span>(element === window || element === document) {
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
    <span class="keyword">var</span> container = element.ownerDocument.documentElement;
    <span class="keyword">if</span>(container.contains) {
        <span class="keyword">return</span> container.contains(element);
    } <span class="keyword">else</span> <span class="keyword">if</span>(container.compareDocumentPosition) {
        <span class="keyword">return</span> !(container.compareDocumentPosition(element) &amp; Node.DOCUMENT_POSITION_DISCONNECTED);
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
};</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private method triggerForPath</span></p>
<p>Dispatch the event at the element and its ancestors.
Required to support delegated events in browsers that don&#39;t bubble events in detached DOM trees.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>element must be a Node.</strong><br/>(First element to dispatch the event)</p>
</li>
<li><p><strong>type must be a String.</strong><br/>(Type of the event)</p>
</li>
<li><p><strong>params is optional and must be an Object.</strong><br/>(Event parameters (optional))</p>
<ul>
<li><p><strong>params.bubbles must be a Boolean and has a default value of true.</strong><br/>(Does the event bubble up through the DOM or not. Will be set to false (but shouldn&#39;t matter since events don&#39;t bubble anyway).)</p>
</li>
<li><p><strong>params.cancelable must be a Boolean and has a default value of true.</strong><br/>(Is the event cancelable or not.)</p>
</li>
<li><p><strong>params.detail can be of any type and has a default value of undefined.</strong><br/>(Additional information about the event.)</p>
</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> triggerForPath = <span class="function"><span class="keyword">function</span><span class="params">(element, type, params)</span> {</span>
    params = params || {};
    params.bubbles = <span class="literal">false</span>;
    <span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(type, params);
    event._target = element;
    <span class="keyword">while</span>(element.parentNode) {
        element.dispatchEvent(event);
        element = element.parentNode;
    }
};</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private method getHandlers</span></p>
<p>Get event handlers from an element</p>
<p>Parameters:</p>
<ul>
<li><strong>element must be a Node.</strong></li>
</ul>
<p><strong>Returns an Array</strong></p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> cacheKeyProp = <span class="string">'_jeh'</span>;
<span class="keyword">var</span> id = <span class="number">1</span>;
<span class="keyword">var</span> handlers = {};
<span class="keyword">var</span> unusedKeys = [];

<span class="keyword">var</span> getHandlers = <span class="function"><span class="keyword">function</span><span class="params">(element)</span> {</span>
    <span class="keyword">if</span>(!element[cacheKeyProp]) {
        element[cacheKeyProp] = unusedKeys.length === <span class="number">0</span> ? ++id : unusedKeys.pop();
    }
    <span class="keyword">var</span> key = element[cacheKeyProp];
    <span class="keyword">return</span> handlers[key] || (handlers[key] = []);
};</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private method clearHandlers</span></p>
<p>Clear event handlers for an element</p>
<p>Parameters:</p>
<ul>
<li><strong>element must be a Node.</strong></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> clearHandlers = <span class="function"><span class="keyword">function</span><span class="params">(element)</span> {</span>
    <span class="keyword">var</span> key = element[cacheKeyProp];
    <span class="keyword">if</span>(handlers[key]) {
        handlers[key] = <span class="literal">null</span>;
        element[key] = <span class="literal">null</span>;
        unusedKeys.push(key);
    }
};</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private method delegateHandler</span></p>
<p>Function to test whether delegated events match the provided <code>selector</code> (filter),
and then actually call the provided event handler.
Also sets <code>event.currentTarget</code> on the event object.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>selector must be a String.</strong><br/>(Selector to filter descendants that undelegate the event to this element.)</p>
</li>
<li><p><strong>fn must be a Function.</strong><br/>(Event handler)</p>
</li>
<li><p><strong>event must be an Event.</strong></p>
</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> delegateHandler = <span class="function"><span class="keyword">function</span><span class="params">(selector, handler, event)</span> {</span>
    <span class="keyword">var</span> eventTarget = event._target || event.target;
    <span class="keyword">if</span>(matchesSelector.call(eventTarget, selector)) {
        <span class="keyword">if</span>(!event.currentTarget) {
            event.currentTarget = eventTarget;
        }
        handler.call(eventTarget, event);
    }
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the available <code>matches</code> or <code>matchesSelector</code> method.</p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> matchesSelector = (<span class="function"><span class="keyword">function</span><span class="params">(global)</span> {</span>
    <span class="keyword">var</span> context = <span class="keyword">typeof</span> Element !== <span class="string">'undefined'</span> ? Element.prototype : global;
    <span class="keyword">return</span> context.matches || context.matchesSelector || context.mozMatchesSelector || context.webkitMatchesSelector || context.msMatchesSelector || context.oMatchesSelector;
})(<span class="keyword">this</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Polyfill for CustomEvent, borrowed from <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill">MDN</a>.
Needed to support IE (9, 10, 11)</p></div></div><div class="code"><div class="wrapper">(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span>(global.CustomEvent) {
        <span class="keyword">var</span> CustomEvent = <span class="function"><span class="keyword">function</span><span class="params">(event, params)</span> {</span>
            params = params || { bubbles: <span class="literal">false</span>, cancelable: <span class="literal">false</span>, detail: <span class="literal">undefined</span> };
            <span class="keyword">var</span> evt = document.createEvent(<span class="string">'CustomEvent'</span>);
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            <span class="keyword">return</span> evt;
        };

        CustomEvent.prototype = global.CustomEvent.prototype;
        global.CustomEvent = CustomEvent;
    }
})();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Are events bubbling in detached DOM trees?</p></div></div><div class="code"><div class="wrapper"><span class="keyword">var</span> isEventBubblingInDetachedTree = (<span class="function"><span class="keyword">function</span><span class="params">(global)</span> {</span>
    <span class="keyword">var</span> isBubbling = <span class="literal">false</span>,
        doc = global.document;
    <span class="keyword">if</span>(doc) {
        <span class="keyword">var</span> parent = doc.createElement(<span class="string">'div'</span>),
            child = parent.cloneNode();
        parent.appendChild(child);
        parent.addEventListener(<span class="string">'e'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            isBubbling = <span class="literal">true</span>;
        });
        child.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">'e'</span>, {bubbles:<span class="literal">true</span>}));
    }
    <span class="keyword">return</span> isBubbling;
})(<span class="keyword">this</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Export interface</p></div></div><div class="code"><div class="wrapper">export { on, off, delegate, undelegate, trigger };</div></div></div></div></body></html>